1. Providing a service with help  
   of `@Injectable` and `providedIn` set to `root`  
   is the most common use case, and therefore,  
   that's how you typically wanna provide your services.  
   **`@Injectable`와 `providedIn`을 `root`로 설정하여  
   서비스를 제공하는 것이 가장 일반적인 방법이며,  
   이는 일반적으로 서비스를 제공할 때 사용하는 방식입니다.**

2. But there are alternative ways.  
   **하지만 다른 방법도 있습니다.**

3. With that disabled, you can, for example,  
   provide that service to your entire application  
   by going to the `main.ts` file  
   and by then passing a second argument  
   to `bootstrapApplication`  
   and that argument should be an object.  
   **`@Injectable` 설정을 비활성화한 경우,  
   예를 들어 `main.ts` 파일로 이동하여  
   `bootstrapApplication`에 두 번째 인수를 전달하여  
   서비스를 전체 애플리케이션에 제공할 수 있습니다.  
   이 인수는 객체여야 합니다.**

4. And this object then has a `providers` property,  
   which you can set up, and this wants an array of providers  
   and a provider, then in the end is a piece of information  
   that lets Angular know that a certain value  
   should be injectable.  
   **이 객체에는 `providers` 속성이 있으며,  
   이를 설정할 수 있습니다.  
   `providers`는 provider의 배열을 요구하며,  
   provider는 특정 값이 주입 가능하다는 정보를  
   Angular에 제공하는 요소입니다.**

5. In its simple form,  
   you can pass the `TasksService`  
   to this `providers` array now,  
   just like this, and Angular will do the rest.  
   **간단하게 `TasksService`를  
   이 `providers` 배열에 전달하면  
   나머지는 Angular가 처리합니다.**

6. With that, you register this `TasksService`  
   with the application root environment injector,  
   just as you would do it  
   with `@Injectable` with `providedIn` set to `root`,  
   but now by using this configuration object  
   on `bootstrapApplication`.  
   **이렇게 하면 `TasksService`를  
   애플리케이션 루트 환경 주입기(environment injector)에  
   등록하게 됩니다.  
   이는 `@Injectable`에서 `providedIn`을 `root`로  
   설정하는 것과 동일하지만,  
   이번에는 `bootstrapApplication`의  
   설정 객체를 사용하여 수행합니다.**

7. With that done, therefore, if you save that,  
   you see the application seems to work again,  
   the error is gone, and that all seems to work again.  
   **이 설정을 완료하고 저장하면,  
   애플리케이션이 다시 작동하고,  
   오류가 사라지며, 모든 것이 정상적으로  
   작동하는 것을 확인할 수 있습니다.**

8. So that's one other way of providing a service.  
   **이것이 서비스를 제공하는 또 다른 방법입니다.**

9. Now one important difference compared  
   to using `@Injectable` with `providedIn` set to `root`  
   is that this approach  
   where you use this configuration object,  
   does not allow for tree shaking of this `TasksService` thing,  
   which in the end means that Angular tries to  
   optimize your code as much as possible  
   once you prepare it for deployment.  
   **`@Injectable`와 `providedIn: 'root'`를 사용하는 것과  
   이 설정 객체를 사용하는 방법의 중요한 차이점은,  
   이 방법은 `TasksService`의 트리 쉐이킹(tree shaking)을  
   허용하지 않는다는 점입니다.  
   트리 쉐이킹은 Angular가 배포를 준비할 때  
   코드를 최대한 최적화하려는 과정입니다.**

10. And during that optimization process,  
    it tries to throw away any code that's not being used  
    or that's at least not needed initially when the app starts.  
    **최적화 과정에서는 사용되지 않거나,  
    애플리케이션 시작 시  
    초기에는 필요하지 않은 코드를 제거하려고 시도합니다.**

11. Now, when you register your injectable value,  
    your `TasksService` with this `providers` array here,  
    and you therefore add this import here,  
    it will always be included in that initial code bundle  
    that is generated by Angular.  
    **이 `providers` 배열에 주입 가능한 값(`TasksService`)을  
    등록하고 이를 가져오는 코드를 추가하면,  
    Angular가 생성하는 초기 코드 번들에  
    항상 포함됩니다.**

12. Because Angular sees that it's needed  
    right from the start here,  
    in this very first code that executes when the app starts.  
    **Angular는 애플리케이션 시작 시 실행되는  
    첫 번째 코드에서 이를 필요로 한다고 간주하기 때문입니다.**

13. Now, if your app would be more complex  
    and this entire tasks feature  
    would maybe only be loaded at a later point of time,  
    the `TasksService` would be included in that initial bundle,  
    even though it technically might not be needed initially.  
    **만약 애플리케이션이 더 복잡하고  
    전체 tasks 기능이 나중에 로드되는 경우,  
    `TasksService`는 초기 번들에 포함됩니다.  
    비록 기술적으로는 처음에는 필요하지 않을 수 있어도 말입니다.**

14. And I'll get back to lazy loading  
    and splitting your code across multiple bundles  
    to improve efficiency a little bit later.  
    **효율성을 높이기 위해 코드의 지연 로드와  
    여러 번들로 분할하는 것에 대해서는  
    나중에 다시 다루겠습니다.**

15. For now, it's just important  
    to take away that with this approach here,  
    this code that belongs to the `TasksService`  
    will always be included.  
    **지금은 이 접근법을 사용하면  
    `TasksService`에 속하는 코드가  
    항상 포함된다는 점을 이해하는 것이 중요합니다.**

16. Whereas if you use `@Injectable` with `providedIn` set to `root`,  
    this is not necessarily the case,  
    and therefore this approach with this decorator  
    and this setting can lead to more optimized code bundles  
    and to a smaller initial code base  
    that's shipped to your users.  
    **반면에 `@Injectable`을 사용하고  
    `providedIn`을 `root`로 설정하면  
    반드시 그렇지는 않으며,  
    이 데코레이터와 설정을 사용하면  
    더 최적화된 코드 번들과 더 작은 초기 코드 베이스가  
    사용자에게 제공될 수 있습니다.**

17. That's why it's typically recommended to use this approach  
    instead of using this `providers` array.  
    **이 때문에 일반적으로  
    `providers` 배열을 사용하는 대신  
    이 접근 방식을 사용하는 것이 권장됩니다.**

18. That's why I will copy this code  
    and then comment it out and remove this from here  
    so that we still see it for reference,  
    but the code isn't active anymore  
    because this is an alternative.  
    **그래서 이 코드를 복사하고 주석 처리한 뒤  
    제거하겠습니다.  
    참조를 위해 여전히 볼 수는 있지만,  
    코드는 더 이상 활성화되지 않도록 하겠습니다.  
    이는 대안적인 방법이기 때문입니다.**

19. But that is typically the better way  
    of providing that value if you want to provide it  
    to the root application injector.  
    **하지만 루트 애플리케이션 주입기에  
    값을 제공하려면 일반적으로  
    이 방법이 더 나은 방법입니다.**

**끝났습니다.**
